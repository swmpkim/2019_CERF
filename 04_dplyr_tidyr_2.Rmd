---
title: "More with dplyr and tidyr"
author: "Kim Cressman"
output: 
    html_document:
        toc: true
        toc_float: yes
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message = FALSE, warning = FALSE}
library(dplyr)
library(tidyr)
library(here)
library(ggplot2)
```

If you don't still have the data frames in your environment, uncomment and run these lines of code (to comment or uncomment multiple lines, you can use the keyboard shortcut `Ctrl` + `Shift` + `C` on Windows and Linux; or `Cmd` + `Shift` + `C` on Mac):  

```{r}
# ebird <- read.csv(here::here("data", "eBird_workshop.csv"), stringsAsFactors = FALSE)
# ebird <- dplyr::distinct(ebird)
# 
# wq <- read.csv(here::here("data", "daily_wq.csv"), stringsAsFactors = FALSE)
# wq_trimmed <- wq %>% 
#     select(station_code, month, day, temp, sal, do_pct, depth) %>% 
#     filter(!is.na(depth)) %>% 
#     mutate(depth_ft = depth * 3.28,
#            temp_f = (9/5) * temp + 32)
```


## Group-wise operations with `group_by()` and `summarize()`  

Say we want to find out how many birds were seen by state in this dataset. We can do that. These operations are also great for lumping data into daily, monthly, or yearly averages (like our SWMP datasets).    

```{r}
ebird %>% 
    group_by(state) %>% 
    summarize(mean_presence = mean(presence, na.rm = TRUE),
              max_presence = max(presence, na.rm = TRUE)) %>% 
    glimpse()
```



We can also group by combinations of multiple variables:  

```{r}
ebird %>% 
    group_by(state, species) %>% 
    summarize(mean_presence = mean(presence, na.rm = TRUE),
              max_presence = max(presence, na.rm = TRUE)) %>% 
    glimpse()
```


You can also sort using `arrange()`. Let's put this in order by species, then state:  

```{r}
ebird %>% 
    group_by(state, species) %>% 
    summarize(mean_presence = mean(presence, na.rm = TRUE),
              max_presence = max(presence, na.rm = TRUE)) %>% 
    arrange(species, state) %>% 
    glimpse()
```


Or put it in order by `max_presence`:  

```{r}
ebird %>% 
    group_by(state, species) %>% 
    summarize(mean_presence = mean(presence, na.rm = TRUE),
              max_presence = max(presence, na.rm = TRUE)) %>% 
    arrange(max_presence) %>% 
    glimpse()
```


To go from highest to lowest instead:  

```{r}
ebird %>% 
    group_by(state, species) %>% 
    summarize(mean_presence = mean(presence, na.rm = TRUE),
              max_presence = max(presence, na.rm = TRUE)) %>% 
    arrange(desc(max_presence)) %>% 
    glimpse()
```



```{r}
ebird %>% 
    select(state, year, samplesize) %>% 
    distinct() %>% 
    glimpse()
```


### (not-so-) mini-challenge 5  

# INSERT CHALLENGE HERE  

***  
***  
***  

# Moving data around with `tidyr`  

# PROBABLY WORTH TALKING ABOUT TIDY DATA GENERALLY AND HADLEY'S PAPER  

The two major functions in `tidyr` are `pivot_longer()` to make your data frame tall and narrow, and `pivot_wider()` to make it shorter and wider. If you've ever heard of/used `gather()` and `spread()`, these are newer, better versions. `gather()` and `spread()` won't go away, but they are deprecated - no longer under active development. It is best to start using the new `pivot` functions moving forward.    

Very often, wide data is the most readable for people. Here is an example:  

# INSERT EXAMPLE OF WIDE DATA  

Good example! C_elegans_tox.csv - a portion of a spreadsheet from Boyd et al., 2015
# look up this citation and link to download data  
in which they compiled toxicity effects of various chemicals on the worm *C. elegans*.  

Let's first take a look at the file:  

```{r}
tox <- read.csv(here::here("data", "C_elegans_tox.csv"), stringsAsFactors = FALSE)
View(tox)
```


This spreadsheet was originally in Excel, and had the $\mu$ symbol for micro-molar. That turned into a `?` when it was saved as csv, and here upon being read in, it just became a period. So most of these columns that end in `.M` should be interpreted as micromolar.  


We'll subset to just the portion that we might want to re-shape, which is the columns that include concentration in the column name. We'll also clean names along the way.  

```{r}
tox_cleaned <- tox %>% 
    janitor::clean_names() %>% 
    select(1:10)


tox_cleaned2 <- tox[1:12, 1:10]   # just pull out the first 12 chemicals to make this dataset more manageable
```


We want to do a few things here: we want a single column for the value of mean *C. elegans* response, and we want to extract the concentrations from the column names and turn them into a variable that we'll call "conc".  

Let's start without worrying about messing with the column names. This is the format we'd use. If we didn't have so many columns to pivot, we could use the column names.  

```{r}
tox_cleaned %>% 
    pivot_longer(cols = 4:10, names_to = "conc", values_to = "response")
```


We can get rid of common prefixes by using `names_prefix`:  

```{r}
tox_cleaned %>% 
    pivot_longer(cols = 4:10, names_to = "conc", values_to = "response",
                 names_prefix = "c_elegans_mean_response")
```


We could also select the columns to pivot by what they start with:  

```{r}
tox_cleaned %>% 
    pivot_longer(cols = starts_with("c_elegans_mean_response"), names_to = "conc", values_to = "response")
```


And we can separate the column as we pivot it:  

```{r}
tox_cleaned %>% 
    pivot_longer(cols = starts_with("c_elegans_mean_response"), 
                 names_to = c("org_genus", "org_species", "type", "var", "conc1", "conc2", "units"),
                 names_sep = "_",
                 values_to = "response")
```




```{r}
tox_long <- tox_cleaned2 %>% 
    pivot_longer(cols = starts_with("C.elegans.mean.response"),
                 names_to = c("prefix","conc","units"),
                 names_sep = "\\.\\.",
                 values_to = "response") %>% 
    mutate(conc = as.numeric(conc))


ggplot(tox_long) +
    geom_point(aes(x = conc, y = response, color = Name), size = 3)

p <- ggplot(tox_long) +
    geom_point(aes(x = conc, y = response, color = Name), size = 3)

p +
    facet_wrap(~Name)

p +
    facet_wrap(~Name) +
    scale_x_log10()


p +
    facet_wrap(~Name) +
    scale_x_log10() +
    theme_bw() +
    labs(title = "Toxicity curves for C. elegans",
         x = "log of concentration (uM)",
         y = "response",
         color = "Chemical name")


# or remove the legend:
p +
    facet_wrap(~Name) +
    scale_x_log10() +
    theme_bw() +
    labs(title = "Toxicity curves for C. elegans",
         x = "log of concentration (uM)",
         y = "response") +
    theme(legend.position = "none")
```




### end  




From Chapter 9 of *The Statistical Sleuth*, 2nd edition, by Ramsey and Schafer. Original data from Huey et al., "Rapid Evolution of a Geographic Cline in Size in an Introduced Fly", *Science* 287 (2000): 308-309.  

These are mean and standard errors of log-transformed wing length in invasive flies. The data has been aggregated and summarized for presentation; we are looking at grouped values.    

```{r}
flies_wide <- read.csv(here::here("data", "flies.csv"), stringsAsFactors = FALSE)
glimpse(flies_wide)
```

We will simplify this a bit to make it easier to learn pivoting.

```{r}
flies <- flies_wide %>% 
    select(Continent, 
           Latitude,
           Female = Female.mean,     # renaming as I select
           Male = Male.mean)
glimpse(flies)
```

In this data set, wing lengths were measured in both female and male flies. Sex is actually a variable, and we can work with the data a little more easily if we make it a column. So we will `pivot_longer()`.  

```{r}
flies_long <- pivot_longer(flies, cols = c(Female, Male), names_to = "sex", values_to = "wing_length")
glimpse(flies_long)
```

This format makes it easier to plot in different ways, or calculate different types of averages. Let's start with some plots.  


```{r}
ggplot(flies_long) +
    geom_point(aes(y = Latitude, x = wing_length), 
               size = 3)
```

Hmmm, looks like we have two different size classes. Could that be related to sex? Let's color by sex (remember, because this is showing something in the data, it goes inside `aes()`):    

```{r}
ggplot(flies_long) +
    geom_point(aes(y = Latitude, x = wing_length, col = sex), 
               size = 3)
```

We may also be curious about whether continent plays a role, and we can represent that by shape.  

```{r}
ggplot(flies_long) +
    geom_point(aes(y = Latitude, x = wing_length, col = sex, shape = Continent), 
               size = 3)
```

Alternately, we could use shape for sex and color for continent.  

When it comes to grouping and summarizing data, tidy data is also easier to use. We will continue to work with the simplified data for a moment. 

Let's say we want to find the average wing length by sex, by continent. That's doable with appropriate subsetting in the original data frame, but it's even easier here:  

```{r}
flies_long %>% 
    group_by(Continent, sex) %>% 
    summarize(mean = mean(wing_length, na.rm = TRUE))
```


And if we simply want the mean by continent, disregarding sex (which may not be the best thing to do, but bear with me), that's exactly as easy:  

```{r}
flies_long %>% 
    group_by(Continent) %>% 
    summarize(mean = mean(wing_length, na.rm = TRUE))
```


#### not really a challenge  

How would you find those averages from the original `flies` data frame?  

```{r}
# it's easy to generate an overall average by sex, but grouping by continent 
# in the original context is tougher
```

You can get more complicated too, by using `pivot_longer_spec()` if you want to keep, e.g., all of the standard error and ratio columns too. Check out `vignette("pivot")` for more details.


The opposite of `pivot_longer()` is `pivot_wider()`. Sometimes you have one observation split over multiple rows, like in a dataset we'll see shortly, and you want to make certain variables be their own columns. To learn how it works, we'll first widen the fly dataset back out, and then work on a slightly more complicated dataset.  

```{r}
flies_wide2 <- flies_long %>% 
    pivot_wider(names_from = sex, values_from = wing_length)
View(flies_wide2)
```


Now let's look at a dataset that has some more going on.  

```{r}
gtmnut <- read.csv(here::here("data", "GTM_2019nutrients.csv"), stringsAsFactors = FALSE)
View(gtmnut)
```

This is how Shannon gets her nutrient measurements back from her lab. There is metadata on every row, with every nutrient. This can be very useful! But it can also make it hard to work with the data. So what we'll do is select only the columns we need: station, sample date, nutrient component, and value. Then we'll pivot it out so that each nutrient value is in its own column.  

```{r}
# also do some renaming along the way
gtmnut_trimmed <- gtmnut %>% 
    select(station = StationCode,
           datetime = DateSampled,
           nutrient = ComponentLong,
           value = Result)
View(gtmnut_trimmed)
```

Each sample spans many rows! We'll spread that out so each sample only takes up one row.  

```{r}
gtmnut_wide <- gtmnut_trimmed %>% 
    pivot_wider(names_from = nutrient,
                values_from = value)
View(gtmnut_wide)
```


As you can see, we now have a LOT of columns, and there are special characters in their names. We'll start by cleaning up the names (remember this `janitor::clean_names()` function?), and then select only a few primary nutrients to work with.  

```{r}
gtmnut_wide <- janitor::clean_names(gtmnut_wide)
View(gtmnut_wide)

gtmnut_wide_trimmed <- gtmnut_wide %>% 
    select(station, datetime, 
           po4 = o_phosphate_p, 
           nox = no2no3_n, 
           fecal_coliform = fecal_coliforms_membrane_filter,
           tss,
           nh4 = ammonia_n,
           total_p,
           chla = chlorophyll_a_corrected)
View(gtmnut_wide_trimmed)
```



#### end  

But to work well with R (and many other languages and analytical software), it is actually better for data to be in a "long" format:  

# INSERT EXAMPLE OF LONG DATA  

SHANNON'S nutrient data that they get back from the lab! Sometimes your data is *too* long, and every observation is split over multiple rows for various reasons. To work with it, we want to give each nutrient its own column (and do something else with all the associated metadata like MDL etc., but that's beyond the scope).    

## long-to-wide  

The data sets we've been using are in a long format. Can you picture a more readable way to present some of this ebird data? Maybe a column for each state, a row for each species/year combination, and presence in the main cells of the table? We can do that, fairly easily.  

```{r}
ebird_wide2 <- ebird %>% 
    select(-samplesize) %>% 
    pivot_wider(names_from = state,
                values_from = presence)

ebird_wide2 %>% 
    arrange(species, year) %>% 
    View()
```


### mini-challenge 6  

You can make a more bite-sized table by filtering to a single species, state, or year of interest. Try making a table of American Coot presence in AL, FL, and MS. Give each state its own column, and each year its own row. (There is more than one way to do this, so compare your answer to your neighbors! Hint: you can use `select()` and/or `filter()` at the beginning of a pipe, and pivot_wider at the end.)    

```{r}

```


## wide-to-long  

What you'll encounter more often is getting data in a wide format, and needing to narrow it. The function for this is `pivot_longer()`. It's similar to `pivot_wider()`.   
